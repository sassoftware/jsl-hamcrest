// Copyright Â© 2019, SAS Institute Inc., Cary, NC, USA.  All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

// Hamcrest for JSL (see hamcrest.org)
// Modeled after standard Java hamcrest and PyHamcrest
Names Default To Here( 0 );

Include( "MatchInfo.jsl" );
Include( "Utils.jsl" );

ut include jsl files recursively( "Matchers" );
ut include jsl files recursively( "Reporters" );

// Section: Globals

/* 
	Function: ut assert that
		---Prototype---
		ut assert that( expression test_expr, UtMatcher matcher, string label = "" )
		---------------
		Assertion function that accepts matchers to determine successes and failures.

	Returns:
		If the assertion passed (1) or failed (0)

	Prototype:
		> ut assert that( test expr, matcher | expected, <label> )

	Parameters:
		test_expr - value about which we are asserting
		matcher - does test expr satisify this matcher or expected value?
		label - extra information about this assertion (optional)

	Examples:
		----------JSL-----------
		// Without a matcher, it defaults to the ut equal to() matcher
		ut assert that( Expr( 5 + 5 ), 10 );
		// The above is equivalent to:
		ut assert that( Expr( 5 + 5 ), ut equal to( 10 ) );
		// Some matchers accept inner matchers
		ut assert that( Expr( Show( 5 + 5 ) ), ut log is( ut equal to ignoring whitespace( "5 + 5 = 10;" ) ) );
		------------------------  
*/
ut assert that = Function( {test expr, matcher, label = ""},
	{did match, did throw, match info}, 
	
	// Ensure that test expr is an expression
	// This is done more for safety than for necessity.
	//
	// If there is no test suite to capture any unexpected
	// throws, any throw escaping a call to ut assert that
	// (including the implicit evaluation of its arguments) will
	// end the entire test file and potentially skip a lot of
	// tests. Instead, we force the user to assert only on
	// expressions, limiting the chance of an throw escaping the
	// call to ut assert that.

	If( !Is Expr( Name Expr( test expr ) ),
		ut global reporter:add expression failure( Name Expr(label) );
		Return( 0 );
	);
	
	matcher = ut ensure matcher( Name Expr( matcher ) );
	
	did throw = 0;
	Try(
		match info = matcher:matches( Name Expr( test expr ) ),
		match info = ut match info failure( "" );
		did throw = ut get exception message( exception_msg );
	);
	
	// Just in case we missed something (match info could be a missing value)
	If( !Is Class( match info ),
		match info = ut match info failure( "the " || (matcher << Get Name) || " failed to return success/failure info. the matcher itself is broken, not the test." );
	);
	
	If( !match info:success,
		If( did throw == 0,
			ut global reporter:add failure(
				Name Expr(label),
				Name Expr( test expr ),
				matcher:describe(),
				match info:mismatch,
				match info:lre
			);
			0;
		,
			ut global reporter:add unexpected throw(
				Name Expr(label),
				Name Expr( test expr ),
				matcher:describe(),
				did throw
			);
			0;
		)
	,
		ut global reporter:add success( Name Expr(label), Name Expr( test expr ), matcher:describe() );
		1;
	);
	
);

// Function: ut is a matcher
//
// This determines (through duck typing) if the given object is
// likely a matcher. 
//
// Returns:
//    1 if maybe matcher is (probably) a matcher, 0 otherwise
//
// Parameters:
//    maybe matcher - any object
//
ut is a matcher = Function( {maybe matcher},
	Try( 
		If( Type( Name Expr( maybe matcher) ) == "Class",
			Name Expr( maybe matcher ) << Contains( "describe" ),
			0	
		),
		0
	)
);

// Function: ut ensure matcher
//
// Conditionally wraps its argument so that the output is always
// a matcher. Does nothing if the argument is already a matcher.
// Wraps with the <Ut Equal To Matcher> otherwise. Often used
// in matcher factory functions.
//
// Returns:
//    A matcher (pass-through or simply wrapped)
//
// Parameters:
//    maybe matcher - any object
//
ut ensure matcher = Function( {maybe matcher},
	If( ut is a matcher( Name Expr( maybe matcher ) ),
		Name Expr( maybe matcher ),
		ut equal to( Name Expr( maybe matcher ) )
	)
);

/*
	Function: ut ensure matcher list
		---Prototype---
		ut ensure matcher list( List<UtMatcher> maybe_matchers )
		---------------
		Convert a list of expressions to a list of matchers
		based on their head expressions.
	
	Arguments:
		maybe_matchers - list of expressions
*/
ut ensure matcher list = Function({matchers},
	{i},
	For( i = 1, i <= N Items( matchers ), i++,
		matchers[i] = If( Contains( ::ut matcher factories, Head( matchers[i] ) ),
			Eval( matchers[i] ),
			ut ensure matcher( matchers[i] )
		);
	);
	matchers;
);

Include( "TestCase.jsl" ); // Requires UtReporter and ut ensure matcher

// Function: ut global lre
//
// Redefine ut global lre to customize how LRE is computed. Default
// behavior is to always return missing (LRE unsupported).
//
// ut global lre() is used by the Equal To and Close To matchers
// to report the LRE value based on actual and expected values.
ut global lre = Function( {actual, expected},
	{i = 1, compute lre},
	compute lre = Function( {actual, expected},
		If( (actual - expected) == 0, 
				16,
			expected != 0 & actual != 0,
				-Log10( Abs( (actual - expected) / Abs( expected ) ) ),
			actual != 0, 
				-Log10( Abs( actual ) ),
				-Log10( Abs( expected ) )
		)
	);
	If(
		Is Number( Name Expr( actual ) ) & Is Number( Name Expr( expected ) ),
			compute lre( actual, expected ),
		Is Matrix( Name Expr( actual ) ) & Is Matrix( Name Expr( expected ) ),
			If( N Row( actual ) == N Row( expected ) & N Col( actual ) == N Col( expected ),
				J( N Row( actual ), N Col( actual ), compute lre( actual[i], expected[i++] ) )
			)
	);
);

// Constant: ut global reporter
//
// Redefine ut global reporter to customize how assert successes
// and failures are reported when using ut assert that. 
ut global reporter = ut reporter();
